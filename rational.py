from integer import *
from natural import *


# Задача Q-1(RED_Q_Q): "Сокращение дроби"
# автор: Пелагейко А.А. 1310

# Входные данные:
# Программа принимает на вход одно рациональное число, представленное следующим образом:
# Q[b, n1, A1[..], n2, A2[..]], где b - знак числа
# n1, A1[..] - числитель (натуральное число), n2, A2[..] - знаменатель (натуральное число)

# Алгоритм:
# получаем НОД числителя и знаменателя
# делим абстолютное значение чилителя и знаменатель на НОД числителя и знаменателя

# Выходные данные:
# Программа возвращает одно рациональное число, представленное следующим образом:
# Q[b, n1, A1[..], n2, A2[..]], где b - знак числа
# n1, A1[..] - числитель (натуральное число), n2, A2[..] - знаменатель (натуральное число)

def RED_Q_Q(Q):
    cA, nodA = GCF_NN_N(Q[1], Q[2], Q[3], Q[4])

    Q[1], Q[2] = DIV_NN_N(Q[1], Q[2], cA, nodA)
    Q[3], Q[4] = DIV_NN_N(Q[3], Q[4], cA, nodA)

    return Q


# Задача Q-2(INT_Q_B): "Проверка рационального числа на целое"
# Выполнил Богданов Г.В. 1310

# Входные данные:
# Программа принимает на вход одно рациональное число, представленное следующим образом:
# Q[b, n1, A1[..], n2, A2[..]], где b - знак числа
# n1, A1[..] - числитель (натуральное число), n2, A2[..] - знаменатель (натуральное число)

# Алгоритм:
# Программа проверяет знаменатель числа на то, равен ли он 1.
# Так как дробь сокращена, то число будет являться целым тогда и лишь тогда, когда знаменатель числа будет равен 1.

# Выходные данные:
# Если число целое, программа возвращает 1, в противном случае программа возвращает 0.

def INT_Q_B(Q):
    return 1 if Q[3] == 1 and Q[4][0] == 1 else 0


# Задача Q-3(TRANS_Z_Q):"Преобразование целого в дробное"
# Выполнил: Ескин Кирилл 1310

# Входные данные:
# Программа принимает на вход целое число, представленное следующим образом:
# Целое число (b, n; A[..]) - знак числа (1 — минус, 0 — плюс), номер старшей позиции и массив цифр

# Алгоритм:
# Добавляем к целому числу знаменатель, тем самым преобразовывая его в рациональное

# Выходные данные:
# Программа возвращает одно рациональное число, представленное следующим образом:
# Q[b, n1, A1[..], n2, A2[..]], где b - знак числа
# n1, A1[..] - числитель (натуральное число), n2, A2[..] - знаменатель (натуральное число)

def TRANS_Z_Q(b1, n1, A1):
    return [b1, n1, A1, 1, [1]]


# Задача Q-4(TRANS_Q_Z: "Преобразование дробного в целое (если знаменатель равен 1)"
# Выполнил Данилов А.С. 1310

# Входные данные:
# Q - это массив из 5 элементов: первые три хранят информацию о целом числе (числителе),
# последние два - о натуральном (знаменателе). Подробнее смотреть в таблице "Типы данных".

# Алгоритм:
# Если номер старшей позиции числа в знаменателе (в массиве это Q[3]) равен 1 и число с индексом 0 в массиве равно 1, значит,
# знаменатель равен 1. Следовательно, дробное число можно преобразовать в целое;
# в этом случае программа возвращает числитель.
# Если знаменатель дроби не равен одному, то возвращается 0.

# Выходные данные:
# Если преобразование возможно:
# Целое число (b, n; A[..]) - знак числа (1 — минус, 0 — плюс), номер старшей позиции и массив цифр
# Иначе 0

def TRANS_Q_Z(Q):
    return [Q[0], Q[1], Q[2]] if Q[3] == 1 and Q[4][0] == 1 else 0


# Задача Q-5(ADD_QQ_Q): "Сложение дробей"
# Выполнил Богданов Г.В. 1310

# Входные данные:
# Q1 и Q2 - это рациональные числа.
# Каждое число - это массив из 5 элементов, где Q[0] - знак числа, Q[1] - номер старшей позиции числителя.
# Q[2] - массив цифр числителя, Q[3] - номер старшей позиции знаменателя, Q[4] - массив цифр знаменателя.

# Алгоритм:
# Находим НОК знаменателей Q1 и Q2.
# Приводим обе дроби к общему знаменателю, приравнивая знаменатель к НОК, и умножая числитель на (НОК/знаменатель числа).
# Получаем новое рациональное число, в котором числитель - сумма  полученных числителей Q1 и Q2, а
# знаменатель - НОК знаменателей Q1 и Q2.
# Сокращаем дробь, если возможно

# Выходные данные:
# Программа возвращает одно рациональное число -  сумму двух рациональных чисел.

def ADD_QQ_Q(Q1, Q2):
    denominator = LCM_NN_N(Q1[3], Q1[4], Q2[3], Q2[4])

    num1 = DIV_NN_N(denominator[0], denominator[1], Q1[3], Q1[4])
    num1 = TRANS_N_Z(num1[0], num1[1])
    minuend = MUL_ZZ_Z(Q1[0], Q1[1], Q1[2], num1[0], num1[1], num1[2])

    num2 = DIV_NN_N(denominator[0], denominator[1], Q2[3], Q2[4])
    num2 = TRANS_N_Z(num2[0], num2[1])
    subtrahend = MUL_ZZ_Z(Q2[0], Q2[1], Q2[2], num2[0], num2[1], num2[2])

    numerator = ADD_ZZ_Z(minuend[0], minuend[1], minuend[2], subtrahend[0], subtrahend[1], subtrahend[2])

    result = RED_Q_Q([numerator[0], numerator[1], numerator[2], denominator[0], denominator[1]])

    return result


# Задача Q-6(SUB_QQ_Q): "Вычитание дробей"
# Выполнил Данилов А.С. 1310

# Входные данные:
# Q1 и Q2 - это рациональные числа (дроби), которые передаются в виде массивов (см. таблицу "Типы данных").
# Каждое число - это массив из 5 элементов: первые три хранят информацию о целом числе (числителе),
# последние два - о натуральном (знаменателе).

# Алгоритм:
# Для вычитания дробей используется обычный "школьный" алгоритм. Сначала находится общий знаменатель
# (это НОК знаменателей исходных дробей), а после числитель каждой дроби домножается на частное от общего знаменателя
# и знаменателя исходной дроби (делим НОК на знаменатель дроби и результат умножаем на числитель,
# то есть приводим дроби к общему знаменателю). После вычитаем получившиеся числа и, если возможно, сокращаем дробь.

# Выходные данные:
# Программа возвращает одно рациональное число -  разность двух рациональных чисел.

def SUB_QQ_Q(Q1, Q2):
    if Q1 == [0, 1, [0], 1, [1]]:
        number = MUL_ZM_Z(Q2[0], Q2[1], Q2[2])
        return [number[0], number[1], number[2], Q2[3], Q2[4]]
    elif Q2 == [0, 1, [0], 1, [1]]:
        return Q1
    else:

        denominator = LCM_NN_N(Q1[3], Q1[4], Q2[3], Q2[4])

        number1_N = DIV_NN_N(denominator[0], denominator[1], Q1[3], Q1[4])
        number1_Z = TRANS_N_Z(number1_N[0], number1_N[1])
        minuend = MUL_ZZ_Z(Q1[0], Q1[1], Q1[2], number1_Z[0], number1_Z[1], number1_Z[2])

        number2_N = DIV_NN_N(denominator[0], denominator[1], Q2[3], Q2[4])
        number2_Z = TRANS_N_Z(number2_N[0], number2_N[1])
        subtrahend = MUL_ZZ_Z(Q2[0], Q2[1], Q2[2], number2_Z[0], number2_Z[1], number2_Z[2])

        numerator = SUB_ZZ_Z(minuend[0], minuend[1], minuend[2], subtrahend[0], subtrahend[1], subtrahend[2])

        result = RED_Q_Q([numerator[0], numerator[1], numerator[2], denominator[0], denominator[1]])

        return result


# Задача Q-7(MUL_QQ_Q): "Умножение дробей"
# Выполнила Прокофьева К.А. 1310

# Входные данные:
# Программа принимает на вход два рациональных числа, представленных следующим образом:
# Q[b, n1, A1[..], n2, A2[..]], где b - знак числа
# n1, A1[..] - числитель (натуральное число), n2, A2[..] - знаменатель (натуральное число)

# Алгоритм:
# Умножаем дроби (числитель первой умножаенаем на числитель второй, знаменатель первой умножаем на знаменатель второй) используя функцию MUL_ZZ_Z.
# Используем срез, чтобы присвоить переменной amount2 номер старшей позиции, а переменной number2 - массив цифр
# Сокращаем дробь

# Выходные данные:
# В результате программа возвращает одно рациональное число, представленное следующим образом:
# Q[b, n1, A1[..], n2, A2[..]], где b - знак числа
# n1, A1[..] - числитель (натуральное число), n2, A2[..] - знаменатель (натуральное число)

def MUL_QQ_Q(A, B):
    sign, amount1, number1 = MUL_ZZ_Z(A[0], A[1], A[2], B[0], B[1], B[2])
    amount2, number2 = MUL_ZZ_Z(0, A[3], A[4], 0, B[3], B[4])[1:]
    result = RED_Q_Q([sign, amount1, number1, amount2, number2])
    return result


# Задача Q-8(DIV_QQ_Q): "Деление дробей (делитель отличен от нуля)"
# Выполнил Чибисов А.А. 1305

# Входные данные:
# Программа принимает на вход два рациональных числа, представленных следующим образом:
# Q[b, n1, A1[..], n2, A2[..]], где b - знак числа
# n1, A1[..] - числитель (натуральное число), n2, A2[..] - знаменатель (натуральное число)

# Алгоритм:
# Умножаем дроби (числитель первой умножаенаем на знаменатель второй, знаменатель первой умножаем на числитель второй) используя функцию MUL_ZZ_Z.
# Используем срез, чтобы присвоить переменной amount2 номер старшей позиции, а переменной number2 - массив цифр
# Сокращаем дробь

# Выходные данные:
# В результате программа возвращает одно рациональное число, представленное следующим образом:
# Q[b, n1, A1[..], n2, A2[..]], где b - знак числа
# n1, A1[..] - числитель (натуральное число), n2, A2[..] - знаменатель (натуральное число)

def DIV_QQ_Q(A, B):
    sign, amount1, number1 = MUL_ZZ_Z(A[0], A[1], A[2], B[0], B[3], B[4])
    amount2, number2 = MUL_ZZ_Z(0, B[1], B[2], 0, A[3], A[4])[1:]
    result = RED_Q_Q([sign, amount1, number1, amount2, number2])
    return result