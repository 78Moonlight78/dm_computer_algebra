# Задача N-1(COM_NN_D): "Сравнение натуральных чисел"
# Выполнил Кашуба Д.А. 1310

# Входные данные:
# Программа принимает на вход два натуральных числа, представленных следующим образом:
# Целое число n1 - номер старшей позиции, и массив цифр arr1[..]
# Целое число n2 - номер старшей позиции, и массив цифр arr2[..]

# Алгоритм:
# 1)Если длина первого больше длины второго, значит первое больше второго.
# 2)Если длина второго больше длины первого, значит второе больше первого.
# 3)Если длины одинаковы, проверяем каждый разряд числа пока не встретим различие: если цифра в рязряде первого числа больше цифры того же разряда второго числа,
# то первое больше второго и наоборот.
# 4)Если длины одинаковы и различий в разрядах нет, то числа равны.

# Выходные данные:
# 2 - если первое больше второго.
# 1 - если второе больше первого.
# 0 - если числа равны.

def COM_NN_D(n1, arr1, n2, arr2):
    if (n1 > n2):
        return 2
    elif (n1 < n2):
        return 1
    else:
        for i in range(0, n1):
            if (arr1[i] > arr2[i]):
                return 2
            elif (arr1[i] < arr2[i]):
                return 1
        return 0


# Задача N-2(NZER_N_B): "Проверка на ноль"
# Выполнил Волосевич А.Н. 1310

# Входные данные:
# Программа принимает на вход одно натуральное число, представленных следующим образом:
# Целое число n - номер старшей позиции, и массив цифр A[..]

# Алгоритм:
# 1)Проверяем все цифры числа.
# 2)Если хотя бы одна цифра не ноль, число не равно нулю.
# 3)Иначе число равно нулю.

# Выходные данные:
# True - если число не 0
# False - если число 0

def NZER_N_B(n: int, A: list) -> bool:
    for num in A:
        if num != 0:
            return True
    return False


# Задача N-3(ADD_1N_N): "Добавление 1 к натуральному числу"
# Выполнил Поллуксов А.В. 1310

# Входные данные:
# Программа принимает на вход натуральное число, представленное следующим образом:
# Целое число n - номер старшей позиции, и массив цифр arr[..]

# Алгоритм:
# 1)Добавляем 1 к цифре младшего разряда. Если она равна 9, заменяем её на 0 и добавляем 1 к следующему разряду.
# 2)Если программа таким образом дошла до старшего разряда, который равен 9, значит, у числа появится новый разряд.

# Выходные данные:
# Целое число n, массив arr[..]

def ADD_1N_N(n, arr):
    i = n - 1
    while i != -1:
        arr[i] += 1
        if arr[i] == 10:
            arr[i] = 0
            if i == 0:
                arr.insert(0, 1)
                n += 1
            i -= 1
        else:
            i = -1
    return [n, arr]


# Задача N-4(ADD_NN_N): "Сложение натуральных чисел"
# Выполнил Егоров И.М. 1310

# Входные данные:
# Программа принимает на вход A - массив чисел(натуральное число), n_a - количество цифр числа A, то же самое с B.

# Алгоритм:
# Получаем на вход массив чисел. Присваиваем переменным i и j индексы последнего элемента массива.
# С помощью функции COM_NN_D сравниваем два числа. Если В больше А, только меняем их местами.(Для удобства работы)
# Далее, начиная с последнего элемента начинаем прибавлять к элементу А элемент В.
# Если число получается больше 10, то прибавляем к следующему элементу единицу, а само число A[i] делаем остатком.
# (A[i] % 10). Если достигаем старшей цифры числа, а эта цифра оказывается больше или равна 10:
# То с помощью insert добавляем в массив единицу

# Выходные данные:
# Возвращаем массив чисел A (получившаяся сумма) и количество цифр в массиве n_a.

def ADD_NN_N(n_a, A, n_b, B):
    if COM_NN_D(n_a, A, n_b, B) == 1:
        tmp = A
        A = B
        B = tmp
        tmp = n_a
        n_a = n_b
        n_b = tmp
    i = n_a - 1
    j = n_b - 1
    while (i >= 0):
        if j >= 0:
            A[i] += B[j]
        if A[i] >= 10:
            A[i] = A[i] % 10
            if i > 0:
                A[i - 1] += 1
            else:
                A.insert(0, 1)
                n_a += 1
        i -= 1
        j -= 1

    return [n_a, A]


# Задача N-5(SUB_NN_N): "Вычитание натуральных чисел"
# Выполнил Шаров А.К. 1310

# Входные данные:
# Программа принимает на вход два натуральных числа, представленных следующим образом:
# Целое число n1 - номер старшей позиции, и массив цифр a1[..]
# Целое число n2 - номер старшей позиции, и массив цифр a2[..]

# Алгоритм:
# Если числа равны, результат - 0.
# Иначе, проверяем, что первое дейтвительно больше второго.
# Далее, алгоритм вычитания в столбик:
# - начиная с младшего разряда, вычитаем из первой цифры вторую
# - если вторая цифра больше первой, занимаем 1 из следующего разряда
# Результат вычитания записывается в отдельный массив res[..]

# Выходные данные:
# Длина массива res (номер старшей позиции), и сам массив res[..]

def SUB_NN_N(n1: int, a1: list, n2: int, a2: list) -> tuple:
    res = []
    eq = COM_NN_D(n1, a1, n2, a2)
    if eq == 0:
        res.append(0)
    elif eq == 2:
        for i in range(1, n1 + 1):
            while n1 > n2:
                a2 = [0] + a2
                n2 += 1
            if a1[-i] >= a2[-i]:
                res.append(a1[-i] - a2[-i])
                if res[-1] < 0: a1[-i + 1] += 1
            else:
                a1[-i - 1] -= 1
                res.append(a1[-i] - a2[-i] + 10)
        res.reverse()
        while res[0] == 0: res.pop(0)
    return len(res), res


# Задача N-6(MUL_ND_N): "Умножение натурального числа на цифру"
# Выполнил Катрущенко О.Д. 1310

# Входные данные:
# Программа принимает на вход одно натуральное число и цифру
# Целое число n - номер старшей позиции, массив цифр A[..], и цифра D

# Алгоритм:
# Начиная с младшего разряда, перемножаем разряд на цифру
# - если в результате число из одного разряда, записываем его в массив для ответа
# - если в результате число из двух разядов, то записываем его младший разряд в массив для ответа,
#   а старший разряд записываем в вспомогательную переменную, чтобы добавить к результату следующего умножения

# Выходные данные:
# Целое число n, массив B[..]

def MUL_ND_N(n, A, D):
    s = 0
    r = 0
    B = []

    A.reverse()
    for i in range(n):
        s = int(A[i]) * D + int(r)
        s = str(s)
        if (len(s) == 2) and (i + 1 != n):
            B.append(int(s[1]))
            r = s[0]
        if (len(s) == 2) and (i + 1 == n):
            B.append(int(s[1]))
            B.append(int(s[0]))
            if len(s) == 1:
                B.append(int(s[0]))
            r = 0
            B.reverse()
            while (B[0] == 0 and len(B) > 1):
                B.pop(0)
    n = len(B)
    return n, B


# Задача N-7(MUL_Nk_N): "Умножение натурального числа на 10^k"
# Выполнил Пелагейко А.А. 1310

# Входные данные:
# Программа принимает на вход одно натуральное число и коэффициент
# Целое число n - номер старшей позиции, массив цифр A[..], и коэффициент k

# Алгоритм:
# заполняем элементы списка нулями, начиная с n-ного элемента и заканчивая n+k
# т.к. итоговое число будет содержать в себе n+k элементов
# увеличиваем счётчик кол-ва цифр
# имеем число n и список a_t, содержащий в себе число, умноженное на 10^k и разбитое на цифры

# Выходные данные:
# Целое число n, массив a_t[..]

def MUL_Nk_N(n, A, k):
    a_t = A.copy()
    for i in range(n, n + k):
        a_t.insert(i, 0)
    n += k
    return n, a_t


# Задача N-8(MUL_NN_N): "Умножение натурального числа на 10^k"
# Выполнил Пелагейко А.А. 1310

# Входные данные:
# Программа принимает на вход два натуральных числа, представленных следующим образом:
# Целое число n1 - номер старшей позиции, и массив цифр A[..]
# Целое число n2 - номер старшей позиции, и массив цифр B[..]

# Алгоритм:
# если первое число меньше второго - меняем их местами (для удобства работы)
# перемножаем первое число поочерёдно с каждой цифрой из второго числа, начиная с младших разрядов
# сдвигаем разряд произведения, умножив полученное слагаемое на 10^k
# складываем полученные результаты произведений (сумма накапливается в массиве mul0)
# увеличиваем сдвиг (переменная k) на 1

# Выходные данные:
# Целое число c2, массив mul0[..]

def MUL_NN_N(n1, A, n2, B):
    mul0 = []
    k = 0

    if A == [0] or B == [0]:
        c2 = 1
        mul0.insert(0, 0)
    else:

        if COM_NN_D(n1, A, n2, B) == 1:
            A, B = B, A
            temp = n1
            n1 = n2
            n2 = temp

        for i in range(len(B) - 1, -1, -1):
            c, L = MUL_ND_N(len(A), A, B[i])
            A.reverse()

            c1, L = MUL_Nk_N(c, L, k)

            c2, mul0 = ADD_NN_N(len(mul0), mul0, c1, L)

            k = k + 1
    return [c2, mul0]


# Задача N-9(SUB_NDN_N): "Вычитание из натурального другого натурального, умноженного на цифру для случая с неотрицательным результатом"
# Выполнил Кашуба Д.А. 1310

# Входные данные:
# Программа принимает на вход два натуральных числа, представленных следующим образом:
# Целое число n1 - номер старшей позиции, и массив цифр arr1[..]
# Целое число n2 - номер старшей позиции, и массив цифр arr2[..]
# и цифра D, на которую необходимо умножить

# Алгоритм:
# Умножаем на число, с помощью функции MUL_ND_N, вычитаем, с помощью функции SUB_NN_N, в которой уже есть проверка на то, равны ли числа

# Выходные данные:
#  n_res - длина числа
#  A_res - результат вычитания

def SUB_NDN_N(n1, A1, n2, A2, D):
    A_res = []
    n2, A2 = MUL_ND_N(n2, A2, D)
    n_res, A_res = SUB_NN_N(n1, A1, n2, A2)
    return n_res, A_res


# Задача N-10(DIV_NN_Dk): "Вычисление первой цифры деления большего натурального на меньшее,
# домноженное на 10^k,где k - номер позиции этой цифры (номер считается с нуля)"
# Выполнил Поллуксов А.В. 1310

# Входные данные:
# Программа принимает на вход 2 натуральных числа, представленных следующим образом:
# Целое число (n; arr[..]) - номер старшей позиции и массив цифр

# Алгоритм:
# 1)Циклично умножаем меньшее число на 10, если в результате оно не будет больше бо́льшего числа
# 2)Параллельно с шагом (1) считаем отступ k
# 3)Пока первое число больше второго, отнимаем из бо́льшего меньшее
# 4)Параллельно с шагом (3) считаем цифру d

# Выходные данные:
# Первая цифра деления d и его позиция k

def DIV_NN_Dk(n_1, arr1, n_2, arr2):
    arr_1 = arr1.copy()
    arr_2 = arr2.copy()
    k = 0
    while COM_NN_D(n_1, arr_1, n_2 + 1, arr_2 + [0]) != 1:
        n_2, arr_2 = MUL_Nk_N(n_2, arr_2, 1)
        k += 1
    d = 0
    while COM_NN_D(n_1, arr_1, n_2, arr_2) != 1:
        n_1, arr_1 = SUB_NN_N(n_1, arr_1, n_2, arr_2)
        d += 1
    return [d, k]


# Задача N-11(DIV_NN_N): "Частное от деления натуральных чисел"
# Выполнил Егоров И.М. 1310

# Входные данные:
# n_1 - длина первого числа, arr_1 - массив цифр первого числа,
# n_2 - длина второго числа, arr_2 - массив цифр второго числа.

# Алгоритм:
# Создаем результирующий массив k. s - длина массива k. С помощью функции DIV_NN_Dk вычисляем первую цифру частного (arr1 / arr2)
# Прибавляем ее в результирующий массив k. С помощью функции MUL_Nk_N умножаем делитель (arr2) на 10 в степени k_t.
# Вычитаем с помощью функции SUB_NDN_N из arr1 число полученное число t_2 длины t_1 (это arr2 умноженное на 10^k_t)
# Прибавляем 1 к длине результата.

# Выходные данные:
# Возвращаем результирующий массив k (частное от деления arr1 на arr2 без остатка) и длину этого массива s.

def DIV_NN_N(n_1, arr_1, n_2, arr_2):
    d_t, k_t = DIV_NN_Dk(n_1, arr_1, n_2, arr_2)
    s = k_t + 1
    k = [0 for i in range(s)]
    while (k_t != 0):
        k[s - k_t - 1] = d_t
        t_1, t_2 = MUL_Nk_N(n_2, arr_2, k_t)
        n_1, arr_1 = SUB_NDN_N(n_1, arr_1, t_1, t_2, d_t)
        d_t, k_t = DIV_NN_Dk(n_1, arr_1, n_2, arr_2)
    k[s - k_t - 1] = d_t
    return [s, k]


# Задача N-12(MOD_NN_N): "Остаток от деления большего натурального числа на меньшее или равное натуральное с остатком(делитель отличен от нуля)"
# Выполнил Козориз К.И. 1310

# Входные данные:
# Программа принимает на вход два целых числа, представленных следующим образом:
# Число n1, обозначающее кол-во разрядов, и массив arr1[...] размера n1, содержащий цифры в этих разрядах для первого числа
# Аналогично, n2 и arr2[...] для второго числа

# Алгоритм:
# С помощью DIV_NN_N находим частное, проверяем не равно ли оно 0, если равно - значит наш массив меньше второго массива, поэтому он является остатком
# Если не равно 0 - с помощью SUB_NDN_N вычитаем из первого числа второе, домноженное на результат деления

# Выходные данные:
# Программа возвращает длину массива и сам массив целых чисел - остаток от деления

def MOD_NN_N(n1, arr1, n2, arr2):
    b = arr1.copy()
    while len(arr1) >= n2:
        arr1 = b.copy()
        a = DIV_NN_N(n1, arr1, n2, arr2)[1]
        arr1 = b

        if a[0] == 0:
            return n1, arr1
        n1, b = SUB_NDN_N(n1, b, n2, arr2, 1)
        arr2.reverse()

    return n1, arr1


# Задача N-13(GCF_NN_N): "НОД натуральных чисел"
# Выполнил Козориз К.И. 1310

# Входные данные:
# Программа принимает на вход два целых числа, представленных следующим образом:
# Число n1, обозначающее кол-во разрядов, и массив arr1[...] размера n1, содержащий цифры в этих разрядах для первого числа
# Аналогично, n2 и arr2[...] для второго числа

# Алгоритм:
# Проверяем какое из двух чисел больше с помощтю функции COM_NN_D, идем в цикле while до того момента,
# пока arr1 и arr2 не равны нулю, при этом если arr1 > arr2 - записываем в arr1 остаток от деления arr1 на arr2,
# иначе наоборот, в конце выводим большее из двух массивов

# Выходные данные:
# Программа возвращает длину массива и сам массив целых чисел - НОД двух чисел

def GCF_NN_N(n1, arr1, n2, arr2):
    while NZER_N_B(n1, arr1) == True and NZER_N_B(n2, arr2) == True:
        if COM_NN_D(n1, arr1, n2, arr2) == 2:  # arr1 > arr2
            n1, arr1 = MOD_NN_N(n1, arr1, n2, arr2)
        elif COM_NN_D(n1, arr1, n2, arr2) == 1:  # arr1 < arr2
            n2, arr2 = MOD_NN_N(n2, arr2, n1, arr1)
        else:
            return n1, arr1
    else:
        if COM_NN_D(n1, arr1, n2, arr2) == 2:  # arr1 > arr2
            return n1, arr1
        else:
            return n2, arr2


# N-14(LCM_NN_N): "НОК натуральных чисел"
# Выполнил Данилов А.С. 1310

# Входные данные:
# Программа принимает на вход два натуральных числа, представленных следующим образом:
# Целое число n1 - номер старшей позиции, и массив цифр A1[..]
# Целое число n2 - номер старшей позиции, и массив цифр A2[..]

# Алгоритм:
# НОК двух натуральных чисел равен их произведению, деленному на НОД этих чисел

# Выходные данные:
# Программа возвращает длину массива и сам массив целых чисел - НОК двух чисел

def LCM_NN_N(n1, A1, n2, A2):
    m1, m2 = MUL_NN_N(n1, A1, n2, A2)
    g1, g2 = GCF_NN_N(n1, A1, n2, A2)
    return DIV_NN_N(m1, m2, g1, g2)
