# Выполнил Кашуба Д.А. N-1
def COM_NN_D(n1, arr1, n2, arr2):
    if (n1 > n2):
        return 2
    elif (n1 < n2):
        return 1
    else:
        for i in range(0, n1):
            if (arr1[i] > arr2[i]):
                return 2
            elif (arr1[i] < arr2[i]):
                return 1
        return 0

# Задача N-2: "Проверка на ноль"
# Выполнил Волосевич А.Н.
def NZER_N_B(n: int, A: list) -> bool:
    for num in A:
        if num != 0:
            return True
    return False

# Задача N-3: "Добавление 1 к натуральному числу"
# Выполнил Поллуксов А.В.
def ADD_1N_N(n, arr):
    i = n - 1
    while i != -1:
        arr[i] += 1
        if arr[i] == 10:
            arr[i] = 0
            if i == 0:
                arr.insert(0, 1)
                n += 1
            i -= 1
        else:
            i = -1
    return [n, arr]


#N-4
# Выполнил Егоров И.М
def ADD_NN_N(n_a, A, n_b, B):
    if COM_NN_D(n_a, A, n_b, B) == 1:
        tmp = A
        A = B
        B = tmp
        tmp = n_a
        n_a = n_b
        n_b = tmp
    i = n_a - 1
    j = n_b - 1
    while (i >= 0):
        if j >= 0:
            A[i] += B[j]
        if A[i] >= 10:
            A[i] = A[i] % 10
            if i > 0:
                A[i - 1] += 1
            else:
                A.insert(0, 1)
                n_a += 1
        i -= 1
        j -= 1

    return [n_a, A]


"""
N-5
Выполнил Шаров Антон
Алгоритм: аналогичен вычитанию столбиком

В случае, когда первое число меньше второго (что противоречит условию), функция вернёт (0, [])
"""
def SUB_NN_N(n1: int, a1: list, n2: int, a2: list) -> tuple:
    """
    N-5. Вычитание из первого большего натурального числа второго меньшего или равного
    :param n1: Длина перового числа
    :param a1: Первое число
    :param n2: Длина второго числа
    :param a2: Второе число

    :return: Разность чисел в виде натурального числа - (длина, число)
    """
    res = []  # Итоговое число
    eq = COM_NN_D(n1, a1, n2, a2)  # Для начала сравним входные числа (Нужна функция из N-1) (Здесь мог бы быть match case)
    if eq == 0:  # Случай, когда входные числа равны
        res.append(0)  # Итоговое число 0
    elif eq == 2:  # Случай, когда первое входное число больше второго
        for i in range(1, n1 + 1):  # Пройдём от последних цифр чисел до первых
            # Приведём два числа к одинаковой длине
            while n1 > n2:
                a2 = [0] + a2
                n2 += 1

            # Имитация вычитания столбиком
            if a1[-i] >= a2[-i]:
                res.append(a1[-i] - a2[-i])  # Добавление в итоговое число результата вычитания
                if res[-1] < 0: a1[-i + 1] += 1  # Случай когда позаимствовали разряд у нуля
            else:
                a1[-i - 1] -= 1
                res.append(a1[-i] - a2[-i] + 10)
        res.reverse()

        while res[0] == 0: res.pop(0)  # Уберём незначащие нули в начале

    return len(res), res


#Задача N-6 "Умножение натурального числа на цифру"
#Выполнила Катрущенко О.Д.
def MUL_ND_N(n, A, D):
    s=0                                                   #переменная, содержащая результат умножения цифры натурального числа на заданную цифру
    r=0                                                   #переменная, содержащая значение десятков результата умножения цифры числа на заданную цифру
    B=[]                                                  #массив, в который добавляются цифры полученного произведения

    A.reverse()                                          #переставление элементов массива A в обратном порядке для прохода по всем цифрам числа с последней
    for i in range(n):
        s = int(A[i])*D + int(r)                         #переменной s присваивается значение произведения цифры числа на заданную цифру и добавленный к этому десяток от предыдущего умножения цифры на цифру
        s = str(s)
        if (len(s)==2) and (i+1!=n):                      #цикл для случаев, когда s не является результатом умножения первой цифры числа на заданную цифру и s - двузначное
            B.append(int(s[1]))                                #в массив B добавляется значение разряда единиц числа s
            r = s[0]                                      #r принимает значение разрда десятков числа s
        if (len(s)==2) and (i+1==n):                      #цикл для случаев, когда s является результатом умножения первой цифры числа на заданную цифру и s - двузначное
            B.append(int(s[1]))                                #в массив B добавляется значение всего числа s
            B.append(int(s[0]))
        if len(s)==1:                                     #цикл для случаев, когда s - цифра
            B.append(int(s[0]))                                #в массив B добавляется значение числа s
            r=0                                           #r равно 0, т.к. в этом цикле у s отсутствует разряд десятков
    B.reverse()                                           #переставление элементов массива B в обратном порядке для записи полученного ответа
    while(B[0] == 0 and len(B) > 1):                      #удаление незначащих нулей, для случая умножения на 0
        B.pop(0)
    n = len(B)
    return n, B


# N-7 Умножение натурального числа на 10^k
# автор: Пелагейко Анастасия 1310
def MUL_Nk_N(n, A, k):
    # создаём копию массива, чтобы не изменить оригинал (важно в других функциях)
    a_t = A.copy()
    # заполняем элементы списка нулями, начиная с n-ного элемента и заканчивая n+k
    # т.к. итоговое число будет содержать в себе n+k элементов
    for i in range(n, n + k):
        a_t.insert(i, 0)
    # увеличиваем счётчик кол-ва цифр
    n += k
    # имеем число n и список a_t, содержащий в себе число, умноженное на 10^k и разбитое на цифры
    return n, a_t

# N-8 "Умножение натуральных чисел"
# автор: Пелагейко Анастасия, 1310
def MUL_NN_N(n1, A, n2, B):
    # пустой список, в котором будет храниться результат умножения
    mul0 = []
    # сдвиг разряда (0 - единицы, 1 - десятки и т.д.)
    k = 0

    # если одно из чисел равно нулю
    if A == [0] or B == [0]:
        # c2 - количество цифр в произведении A * B
        c2 = 1
        # массив чисел с результатом умножения теперь хранит только 0
        mul0.insert(0, 0)
    else:
        # удобнее умножать большое число на цифры маленького, так как потребуется меньше итераций в цикле
        # и потебуется складывать меньшее количество слагаемых

        # если первое число меньше второго - меняем их местами
        if COM_NN_D(n1, A, n2, B) == 1:
            A, B = B, A
            # temp - буферная переменная для переприсваивания
            temp = n1
            n1 = n2
            n2 = temp

        for i in range(len(B) - 1, -1, -1):
            # перемножаем первое введённое натуральное число поочерёдно с каждой цифрой из второго числа
            # начиная с конца второго числа

            # используется функция умножения натурального числа на цифру 'MUL_ND_N'
            # c - количество цифр в произведении после умножения натурального числа на цифру
            c, L = MUL_ND_N(len(A), A, B[i])
            A.reverse()  # не относится к основному алгоритму

            # сдвигаем разряд произведения, умножив полученное слагаемое на 10^k

            # используется функция умножения натурального числа на 10^k 'MUL_Nk_N'
            # с1 - количество цифр в произведении после умножения натурального числа на 10^k
            c1, L = MUL_Nk_N(c, L, k)

            # складываем полученные результаты произведений (сумма накапливается в массиве mul0)

            # используется функция сложения натуральных чисел 'ADD_NN_N'
            c2, mul0 = ADD_NN_N(len(mul0), mul0, c1, L)

            # увеличиваем сдвиг на 1
            k = k + 1
    return [c2, mul0]


# Задача N-9: "Вычитание из натурального другого натурального, умноженного на цифру для случая с неотрицательным результатом"
# Выполнил Кашуба Д.А.
def SUB_NDN_N(n1, A1, n2, A2, D):
    A_res = []
    n2, A2 = MUL_ND_N(n2, A2, D)
    n_res, A_res = SUB_NN_N(n1, A1, n2, A2)
    return n_res, A_res

# Задача N-10: "Вычисление первой цифры деления большего натурального на меньшее,
# Выполнил Поллуксов А.В.
def DIV_NN_Dk(n_1, arr1, n_2, arr2):
    arr_1 = arr1.copy()
    arr_2 = arr2.copy()
    k = 0
    while COM_NN_D(n_1, arr_1, n_2 + 1, arr_2 + [0]) != 1:
        n_2, arr_2 = MUL_Nk_N(n_2, arr_2, 1)
        k += 1
    d = 0
    while COM_NN_D(n_1, arr_1, n_2, arr_2) != 1:
        n_1, arr_1 = SUB_NN_N(n_1, arr_1, n_2, arr_2)
        d += 1
    return [d, k]

#Задача N-11
# Выполнил Егоров И.М
def DIV_NN_N(n_1, arr_1, n_2, arr_2):
    d_t, k_t = DIV_NN_Dk(n_1, arr_1, n_2, arr_2)
    s = k_t + 1
    k = [0 for i in range(s)]
    while (k_t != 0):
        k[s - k_t - 1] = d_t
        t_1, t_2 = MUL_Nk_N(n_2, arr_2, k_t)
        n_1, arr_1 = SUB_NDN_N(n_1, arr_1, t_1, t_2, d_t)
        d_t, k_t = DIV_NN_Dk(n_1, arr_1, n_2, arr_2)
    k[s - k_t - 1] = d_t
    return [s, k]


# Задача N-12 "Остаток от деления большего натурального числа на меньшее или равное натуральное с остатком(делитель отличен от нуля)"
# Выполнил Козориз К.И.
def MOD_NN_N(n1, arr1, n2, arr2):
    b = arr1.copy()
    while len(arr1) >= n2:
        arr1 = b.copy()
        a = DIV_NN_N(n1, arr1, n2, arr2)[1]
        arr1 = b

        if a[0] == 0:
            return n1, arr1
        n1, b = SUB_NDN_N(n1, b, n2, arr2, 1)
        arr2.reverse()

    return n1, arr1

# Задача N-13 "НОД натуральных чисел"
# Выполнил Козориз К.И.
def GCF_NN_N(n1, arr1, n2, arr2):
    while NZER_N_B(n1, arr1) == True and NZER_N_B(n2, arr2) == True:
        if COM_NN_D(n1, arr1, n2, arr2) == 2: #arr1 > arr2
            n1, arr1 = MOD_NN_N(n1, arr1, n2, arr2)
        elif COM_NN_D(n1, arr1, n2, arr2) == 1: #arr1 < arr2
            n2, arr2 = MOD_NN_N(n2, arr2, n1, arr1)
        else:
            return n1, arr1
    else:
        if COM_NN_D(n1, arr1, n2, arr2) == 2: #arr1 > arr2
            return n1, arr1
        else:
            return n2, arr2

# N-14 LCM_NN_N (НОК натуральных чисел)
# Выполнил Данилов А.С.
def LCM_NN_N(n1, A1, n2, A2):
    m1, m2 = MUL_NN_N(n1, A1, n2, A2)
    g1, g2 = GCF_NN_N(n1, A1, n2, A2)
    return DIV_NN_N(m1, m2, g1, g2)
