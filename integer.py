from natural import *


# Задача Z-1: "Абсолютная величина числа"
# Выполнил Шлом И. М.
def ABS_Z_N(b, n, A):
    return [n, A]


#Задача Z-2: Определение положительности числа (2 - положительное, 0 — равное нулю, 1 - отрицательное)
#Выполнил Чибисов А.А.
def POZ_Z_D(b, n, A):
    if(A[0] == 0):
        value = 0
    elif(b == 1):
        value = 1
    else:
        value = 2
    return value


# Задача Z-3: "Умножение целого на (-1)"
# Выполнил Серкин Д.А.
def MUL_ZM_Z(b, n, A):
    return [1, n, A] if b == 0 else [0, n, A]


# Задача Z-4
# Выполнил Смирнов М.О.
def TRANS_N_Z(n, A):
    Z = [0, n, A]
    return Z


#Выполнил Шаров Антон
#Z- 5. Преобразование целого неотрицательного в натуральное """
def TRANS_Z_N(b, n, A) -> tuple:
    return n, A


# Задача Z-6
# Выполнил Смирнов М.О.
def ADD_ZZ_Z(b1, n1, A1, b2, n2, A2):
    # POZ_Z_D (Z-2) если оба числа однаковых знаков
    if POZ_Z_D(b1, n1, A1) == POZ_Z_D(b2, n2, A2):
        # то просто складываем как натуральные ADD_NN_N(Z1[1, 2], Z1[1, 2]) (N-4)
        N = ADD_NN_N(n1 , A1, n2, A2)
        Z = [b1, N[0], N[1]]
    else:
        # ABS_Z_N(Z-1) если числа равны по абсолютной величине, то возвращаем ноль
        if COM_NN_D(n1, ABS_Z_N(b1, n1, A1)[1], n2, ABS_Z_N(b2, n2, A2)[1]) == 0:
            Z = [0, 1, [0]]
        # если они разные, то вычисляем какое число больше по алгоритму COM_NN_D(N-1)
        elif COM_NN_D(n1, A1, n2, A2) == 2:
            # то вычитаем из большего меньшее по алгоритму SUB_NN_N(N-5)
            N = SUB_NN_N(n1, A1, n2, A2)
            Z = [b1, N[0], N[1]]
        else:
            N = SUB_NN_N(n2, A2, n1, A1)
            Z = [b2, N[0], N[1]]
    return Z

#Задача Z-7 "Вычитание целых чисел"
#Выполнила Катрущенко О.Д.
def SUB_ZZ_Z(b1, n1, A1, b2, n2, A2):
    B = []
    n = 0
    b = 0

    s1 = POZ_Z_D(b1, n1, A1)                                         #определение знака первого числа (2 - число положительное, 1 - отрицательное)
    s2 = POZ_Z_D(b2, n2, A2)                                         #определение знака второго числа (2 - число положительное, 1 - отрицательное)

    n1, A1 = ABS_Z_N(b1, n1, A1)                                     #получение абсолютной величины (модуля) первого числа
    n2, A2 = ABS_Z_N(b2, n2, A2)                                     #получение абсолютной величины (модуля) второго числа

    k = COM_NN_D(n1, A1, n2, A2)                                     #определение, какое число больше по модулю (2 - если первое, 0 - если числа равны, 1 - если второе)

    if (s2 == 0):                   #если второе число 0, ответ - первое число
        b, n, B = b1, n1, A1
    elif (s1 == 0):                 #если первое число 0, ответ - второе число, умноженное на -1
        b, n, B = MUL_ZM_Z(b2, n2, A2)

    if (((s1==2) and (s2==2)) or ((s1==1) and (s2==1))) and (k==0):  #числа равны и имеют одинаковые знаки, разность равна 0
        B = [0]
        n = 1
        b = 0

    #цикл для следующих условий, при которых разность равна сумме модулей и положительна:
    #1) первое число положительное, второе отрицательное, модули чисел равны
    #2) первое число положительное, второе отрицательное, модуль первого больше модуля второго
    #3) первое число положительное, второе отрицательное, модуль первого числа меньше модуля второго
    if ((s1 == 2) and (s2 == 1) and (k == 0)) or ((s1 == 2) and (s2 == 1) and (k == 2)) or ((s1 == 2) and (s2 == 1) and (k == 1)):
        n, B = ADD_NN_N(n1, A1, n2, A2)
        b = 0

    #цикл для следующих условий, при которых разность равна сумме модулей и отрицательна:
    #1) первое число отрицательное, второе положительное, модули чисел равны
    #2) первое число отрицательное, второе положительное, модуль первого больше модуля второго
    #3) первое число отрицательное, второе положительное, модуль первого числа меньше модуля второго
    if ((s1 == 1) and (s2 == 2) and (k == 0)) or ((s1 == 1) and (s2 == 2) and (k == 2)) or ((s1 == 1) and (s2 == 2) and (k == 1)):
        n, B = ADD_NN_N(n1, A1, n2, A2)
        b = 1

    if (s1 == 2) and (s2 == 2) and (k == 2):  #числа положительные, модуль первого больше модуля второго, разность равна разности модулей и положительна
        n, B = SUB_NN_N(n1, A1, n2, A2)
        b = 0

    if (s1 == 1) and (s2 == 1) and (k == 2):  #числа отрицательные, модуль первого больше модуля второго, разность равна разности модулей и отрицательна
        n, B = SUB_NN_N(n1, A1, n2, A2)
        b = 1

    if (s1 == 2) and (s2 == 2) and (k == 1):  #числа положительные, модуль первого числа меньше модуля второго, разность равна разности модулей и отрицательна
        n, B = SUB_NN_N(n2, A2, n1, A1)
        b = 1

    if (s1 == 1) and (s2 == 1) and (k == 1):  #числа отрицательне, модуль первого числа меньше модуля второго, разность равна разности модулей и положительна
        n, B = SUB_NN_N(n2, A2, n1, A1)
        b = 0

    return (b, n, B)


# Z-8
# Выполнил Серкин Д.А.
def MUL_ZZ_Z(b1, n1, A1, b2, n2, A2):
    # Дважды вызывается функция POZ_Z_D() для определения знака каждого из двух чисел
    b_1 = POZ_Z_D(b1, n1, A1)
    b_2 = POZ_Z_D(b2, n2, A2)

    # Если хотя бы одно число 0, то результат умножения есть 0.
    # На основании этого делаем проверку на наличие 0
    if (b_1 == 0 or b_2 == 0):
        b = 0
        n = 1
        A = [0]
    else:
        # Вызываем функцию ABS_Z_N() дважды для получения абсолютной велечины каждого числа
        n_1, A_1 = ABS_Z_N(b1, n1, A1)
        n_2, A_2 = ABS_Z_N(b2, n2, A2)

        # Далее вызываем фнкцию MUL_NN_N(), которая перемножает два натуральных числа
        n, A = MUL_NN_N(n1, A1, n2, A2)

        # Определяем знак числа, так как натуральные числа всегда положительные,
        # а функция перемножает целые.
        b = (b_1 + b_2) % 2
    return [b, n, A]


# Задача Z-9: "Частное от деления целого на целое"
# Выполнил Шлом И. М.
def DIV_ZZ_Z(b_1, n_1, A_1, b_2, n_2, A_2):
    res = [0, 1, [0]]
    nat_1 = ABS_Z_N(b_1, n_1, A_1)
    nat_2 = ABS_Z_N(b_2, n_2, A_2)
    if POZ_Z_D(b_1, n_1, A_1) == POZ_Z_D(b_2, n_2, A_2) == 2 or (POZ_Z_D(b_1, n_1, A_1) == 2 and POZ_Z_D(b_2, n_2, A_2) == 1):
        res = DIV_NN_N(nat_1[0], nat_1[1], nat_2[0], nat_2[1])
        res = TRANS_N_Z(res[0], res[1])
        res[0] = b_2
    elif (POZ_Z_D(b_1, n_1, A_1) == 1 and POZ_Z_D(b_2, n_2, A_2) == 2) or POZ_Z_D(b_1, n_1, A_1) == POZ_Z_D(b_2, n_2, A_2) == 1:
        res = DIV_NN_N(nat_1[0], nat_1[1], nat_2[0], nat_2[1])
        if MUL_NN_N(res[0], res[1], nat_2[0], nat_2[1]) != nat_1:
            res = ADD_1N_N(res[0], res[1])
        res = TRANS_N_Z(res[0], res[1])
        res[0] = 1 if (POZ_Z_D(b_1, n_1, A_1) == 1 and POZ_Z_D(b_2, n_2, A_2) == 2) else 0
    if (res[1] == 1 and res[2][0] == 0):
        res[0] = 0
    return res


#Z-10
# Выполнил Волосевич А.Н.
def MOD_ZZ_Z(b1: int, n1: int, A1: list, b2: int, n2: int, A2: list) -> tuple:
    # число (частное от деления)
    ch_b, ch_n, ch_A = DIV_ZZ_Z(b1, n1, A1, b2, n2, A2)

    # делитель * частное
    # максимально возможное число меньше делимого и кратное делителю
    dl_b, dl_n, dl_A = MUL_ZZ_Z(b2, n2, A2, ch_b, ch_n, ch_A)

    # изначальное число - максимальное кратное делителю
    # остаток от деления
    res_b, res_n, res_A = SUB_ZZ_Z(b1, n1, A1, dl_b, dl_n, dl_A)

    return res_b, res_n, res_A
