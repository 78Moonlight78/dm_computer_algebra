from natural import *
# Задача Z-1: "Абсолютная величина числа"
# Выполнил Шлом И. М.

def ABS_Z_N(b, n, A):
    return [n, A]

#Задача Z-2: Определение положительности числа (2 - положительное, 0 — равное нулю, 1 - отрицательное)
#Выполнил Чибисов А.А.

# Алгоритм:
# Функция проверяет значение параметров b(1 — минус, 0 — плюс) и n(номер старшей позиции).
def POZ_Z_D(b, n, A):
    if(A[0] == 0):
        value = 0
    elif(b == 1):
        value = 1
    else:
        value = 2
    return value

# Задача Z-3: "Умножение целого на (-1)"
# Выполнил Серкин Д.А.

def MUL_ZM_Z(b, n, A):
    return [1, n, A] if b == 0 else [0, n, A]

# Задача Z-4
# Выполнил Смирнов М.О.

# Алгоритм:
# Программа приводит тип к целочисленному числу вида b, n, A[],
# где b - знак, n - номер старшей позиции в числе, A[] - массив цифр.
def TRANS_N_Z(n, A):
    Z = [0, n, A]
    return Z

"""
Выполнил Шаров Антон
Алгоритм: Отбрасывется знак, поэтому на входе - (знак, длина, число), а на выходе - (длина, число)
"""
def TRANS_Z_N(b, n, A) -> tuple:
    """ Z- 5. Преобразование целого неотрицательного в натуральное """
    return n, A

# Задача Z-6
# Выполнил Смирнов М.О.
# Алгоритм:
# На входе программа проверяет, равны ли знаки у чисел, если да,
# то они складываются по алгоритму сложения натуральных чисел,
# если нет, то вычисляется, какое число больше:
# из большего числа вычитается меньшее по алгоритму вычитания натуральных чисел
# и подставлятся знак большего

def ADD_ZZ_Z(b1, n1, A1, b2, n2, A2):
    # POZ_Z_D (Z-2) если оба числа однаковых знаков
    if POZ_Z_D(b1, n1, A1) == POZ_Z_D(b2, n2, A2):
        # то просто складываем как натуральные ADD_NN_N(Z1[1, 2], Z1[1, 2]) (N-4)
        N = ADD_NN_N(n1 , A1, n2, A2)
        Z = [b1, N[0], N[1]]
    else:
        # ABS_Z_N(Z-1) если числа равны по абсолютной величине, то возвращаем ноль
        if COM_NN_D(n1, ABS_Z_N(b1, n1, A1), n2, ABS_Z_N(b2, n2, A2)) == 0:
            Z = [0, 1, [0]]
        # если они разные, то вычисляем какое число больше по алгоритму COM_NN_D(N-1)
        elif COM_NN_D(n1, A1, n2, A2) == 2:
            # то вычитаем из большего меньшее по алгоритму SUB_NN_N(N-5)
            N = SUB_NN_N(n1, A1, n2, A2)
            Z = [b1, N[0], N[1]]
        else:
            N = SUB_NN_N(n2, A2, n1, A1)
            Z = [b2, N[0], N[1]]
    return Z

#Задача Z-7 "Вычитание целых чисел"
#Выполнила Катрущенко О.Д.
def SUB_ZZ_Z(b1, n1, A1, b2, n2, A2):
    B=[]
    n = 0
    b = 0

    b1 = POZ_Z_D(b1, n1, A1)                                         #определение знака первого числа (2 - число положительное, 1 - отрицательное)
    b2 = POZ_Z_D(b2, n2, A2)                                         #определение знака второго числа (2 - число положительное, 1 - отрицательное)

    n1, A1 = ABS_Z_N(b1, n1, A1)                                     #получение абсолютной величины (модуля) первого числа
    n2, A2 = ABS_Z_N(b2, n2, A2)                                     #получение абсолютной величины (модуля) второго числа

    k = COM_NN_D(n1, A1, n2, A2)                                     #определение, какое число больше по модулю (2 - если первое, 0 - если числа равны, 1 - если второе)

    if (((b1==2) and (b2==2)) or ((b2==1) and (b2==1))) and (k==0):  #числа равны и имеют одинаковые знаки, разность равна 0
        B = [0]
        n = 1
        b = 0

    #цикл для следующих условий, при которых разность равна сумме модулей и положительна:
    #1) первое число положительное, второе отрицательное, модули чисел равны
    #2) первое число положительное, второе отрицательное, модуль первого больше модуля второго
    #3) первое число положительное, второе отрицательное, модуль первого числа меньше модуля второго
    if ((b1 == 2) and (b2 == 1) and (k == 0)) or ((b1 == 2) and (b2 == 1) and (k == 2)) or ((b1 == 2) and (b2 == 1) and (k == 1)):
        n, B = ADD_NN_N(n1, A1, n2, A2)
        b = 0

    #цикл для следующих условий, при которых разность равна сумме модулей и отрицательна:
    #1) первое число отрицательное, второе положительное, модули чисел равны
    #2) первое число отрицательное, второе положительное, модуль первого больше модуля второго
    #3) первое число отрицательное, второе положительное, модуль первого числа меньше модуля второго
    if ((b1 == 1) and (b2 == 2) and (k == 0)) or ((b1 == 1) and (b2 == 2) and (k == 2)) or ((b1 == 1) and (b2 == 2) and (k == 1)):
        n, B = ADD_NN_N(n1, A1, n2, A2)
        b = 1

    if (b1 == 2) and (b2 == 2) and (k == 2):  #числа положительные, модуль первого больше модуля второго, разность равна разности модулей и положительна
        n, B = SUB_NN_N(n1, A1, n2, A2)
        b = 0

    if (b1 == 1) and (b2 == 1) and (k == 2):  #числа отрицательные, модуль первого больше модуля второго, разность равна разности модулей и отрицательна
        n, B = SUB_NN_N(n1, A1, n2, A2)
        b = 1

    if (b1 == 2) and (b2 == 2) and (k == 1):  #числа положительные, модуль первого числа меньше модуля второго, разность равна разности модулей и отрицательна
        n, B = SUB_NN_N(n2, A2, n1, A1)
        b = 1

    if (b1 == 1) and (b2 == 1) and (k == 1):  #числа отрицательне, модуль первого числа меньше модуля второго, разность равна разности модулей и положительна
        n, B = SUB_NN_N(n2, A2, n1, A1)
        b = 0

    return (b, n, B)

# Выполнил Серкин Д.А.
# MUL_ZZ_Z()
# Z-8
def MUL_ZZ_Z(b1, n1, A1, b2, n2, A2):
    # Дважды вызывается функция POZ_Z_D() для определения знака каждого из двух чисел
    b_1 = POZ_Z_D(b1, n1, A1)
    b_2 = POZ_Z_D(b2, n2, A2)

    # Если хотя бы одно число 0, то результат умножения есть 0.
    # На основании этого делаем проверку на наличие 0
    if (b_1 == 0 or b_2 == 0):
        b = 0
        n = 1
        A = [0]
    else:
        # Вызываем функцию ABS_Z_N() дважды для получения абсолютной велечины каждого числа
        n_1, A_1 = ABS_Z_N(b1, n1, A1)
        n_2, A_2 = ABS_Z_N(b2, n2, A2)

        # Далее вызываем фнкцию MUL_NN_N(), которая перемножает два натуральных числа
        n, A = MUL_NN_N(n1, A1, n2, A2)

        # Определяем знак числа, так как натуральные числа всегда положительные,
        # а функция перемножает целые.
        b = (b_1 + b_2) % 2

    return [b, n, A]

# Задача Z-9: "Частное от деления целого на целое"
# Выполнил Шлом И. М.
# Алгоритм:
# 1. Создаются натуральные версии обоих полученных чисел
# 2. Проверяется знак у чисел, полученных на вход
# 3. Находится частное от целочисленного деления натуральных версий чисел
# 4. Если оба числа положительны либо делимое положительно, а делитель отрицателен, результат переводится в целое
#    число, знак устанавливается такой же, как у делителя
# 5. Если оба числа отрицательны либо делимое отрицательно, а делитель положителен, к результату прибавляется 1,
#    после чего он переводится в целое число; если оба числа были отрицательны, устанавливается знак "+",
#    иначе - "-"
# 6. Если делимое число - 0, возвращается 0
# 7. Возвращается полученное частное
def DIV_ZZ_Z(b_1, n_1, A_1, b_2, n_2, A_2):
    res = [0, 1, [0]]
    nat_1 = ABS_Z_N(b_1, n_1, A_1)
    nat_2 = ABS_Z_N(b_2, n_2, A_2)
    if POZ_Z_D(b_1, n_1, A_1) == POZ_Z_D(b_2, n_2, A_2) == 2 or (POZ_Z_D(b_1, n_1, A_1) == 2 and POZ_Z_D(b_2, n_2, A_2) == 1):
        res = DIV_NN_N(nat_1[0], nat_1[1], nat_2[0], nat_2[1])
        res = TRANS_N_Z(res[0], res[1])
        res[0] = b_2
    elif (POZ_Z_D(b_1, n_1, A_1) == 1 and POZ_Z_D(b_2, n_2, A_2) == 2) or POZ_Z_D(b_1, n_1, A_1) == POZ_Z_D(b_2, n_2, A_2) == 1:
        res = DIV_NN_N(nat_1[0], nat_1[1], nat_2[0], nat_2[1])
        if MUL_NN_N(res[0], res[1], nat_2[0], nat_2[1]) != nat_1:
            res = ADD_1N_N(res[0], res[1])
        res = TRANS_N_Z(res[0], res[1])
        res[0] = 1 if (POZ_Z_D(b_1, n_1, A_1) == 1 and POZ_Z_D(b_2, n_2, A_2) == 2) else 0
    return res

#Z-10
# Выполнил Волосевич А.Н.
def MOD_ZZ_Z(b1: int, n1: int, A1: list, b2: int, n2: int, A2: list) -> tuple:

        # число (частное от деления)
        ch_b, ch_n, ch_A = DIV_ZZ_Z(b1, n1, A1, b2, n2, A2)

        # делитель * частное
        # максимально возможное число меньше делимого и кратное делителю
        dl_b, dl_n, dl_A = MUL_ZZ_Z(b2, n2, A2, ch_b, ch_n, ch_A)

        # изначальное число - максимальное кратное делителю
        # остаток от деления
        res_b, res_n, res_A = SUB_ZZ_Z(b1, n1, A1, dl_b, dl_n, dl_A)

        return res_b, res_n, res_A
