from natural import *
# Задача Z-1(ABS_Z_N): "Абсолютная величина числа"
# Выполнил Шлом И.М. 1310

# Входные данные:
# Программа принимает на вход целое число, представленное следующим образом:
# Целое число (b; n; A[..]) - знак перед числом (1 - минус, 0 - плюс), номер старшей позиции и массив цифр

# Выходные данные:
# Натуральное число (n; A[..]) - номер старшей позиции и массив цифр.

def ABS_Z_N(b, n, A):
    return [n, A]


# Задача Z-2(POZ_Z_D): "Определение положительности числа (2 - положительное, 0 — равное нулю, 1 - отрицательное)"
# Выполнил Чибисов А.А. 1305

# Входные данные:
# Функция принимает на вход целое число представленное следующим образом:
# Целое число (b, n; A[..]) - знак числа (1 — минус, 0 — плюс), номер старшей позиции и массив цифр.

# Алгоритм:
# Функция проверяет значение параметров b(1 — минус, 0 — плюс) и A[0] - старший разряд числа.

# Выходные данные:
# В результате программа возвращает целое число(2 - положительное, 0 — равное нулю, 1 - отрицательное)

def POZ_Z_D(b, n, A):
    if (A[0] == 0):
        value = 0
    elif (b == 1):
        value = 1
    else:
        value = 2
    return value


# Задача Z-3(MUL_ZM_Z): "Умножение целого на (-1)"
# Выполнил Серкин Д.А. 1310

# Входные данные:
# Программа принимает на вход целое число представленное следующим образом:
# Целое число (b, n; A[..]) - знак числа (1 — минус, 0 — плюс), номер старшей позиции и массив цифр

# Алгоритм:
# Исходя из условия программа меняет значение переменной b на "противоположное" (1 на 0, 0 на 1)

# Выходные данные:
# В результате программа возвращает целое число представленное следующим образом:
# Целое число (b, n; A[..]) - знак числа (1 — минус, 0 — плюс), номер старшей позиции и массив цифр

def MUL_ZM_Z(b, n, A):
    return [1, n, A] if b == 0 else [0, n, A]


# Задача Z-4(TRANS_N_Z): "Преобразование натурального в целое"
# Выполнил Смирнов М.О. 1305

# Входные данные:
# Программа принимает на вход натуральное число n и массив A[],
# где n - номер старшей позиции в числе, A[] - массив цифр.

# Алгоритм:
# Программа приводит тип к целочисленному числу вида b, n, A[],
# где b - знак, n - номер старшей позиции в числе, A[] - массив цифр.

# Выходные данные:
# Программа возвращает целочисленное значение Z[0, n; A[]]

def TRANS_N_Z(n, A):
    Z = [0, n, A]
    return Z


# Задача Z-5(TRANS_Z_N): "Преобразование целого в натуральное"
# Выполнил Шаров А.К. 1310

# Входные данные:
# Программа принимает на вход целое число представленное следующим образом:
# Целое число (b, n; A[..]) - знак числа (1 — минус, 0 — плюс), номер старшей позиции и массив цифр

# Алгоритм:
# Программа приводит тип к натуральному числу вида n, A[],
# где n - номер старшей позиции в числе, A[] - массив цифр.

# Выходные данные:
# Программа возвращает натуральное число n, A

def TRANS_Z_N(b, n, A) -> tuple:
    return n, A


# Задача Z-6(ADD_ZZ_Z): "Сложение целых чисел"
# Выполнил Смирнов М.О. 1305

# Входные данные:
# Программа принимает на вход два целых числа: b1, n1, A1[] и b2, n2, A2[],
# где b - знак числа, n - номер старшей позиции в числе, A[] - массив цифр.

# Алгоритм:
# На входе программа проверяет, равны ли знаки у чисел, если да,
# то они складываются по алгоритму сложения натуральных чисел,
# если нет, то вычисляется, какое число больше:
# из большего числа вычитается меньшее по алгоритму вычитания натуральных чисел
# и подставлятся знак большего

# Выходные данные:
# Программа возвращает целочисленное значение суммы Z[b, n, A[]]

def ADD_ZZ_Z(b1, n1, A1, b2, n2, A2):
    if POZ_Z_D(b1, n1, A1) == POZ_Z_D(b2, n2, A2):
        N = ADD_NN_N(n1, A1, n2, A2)
        Z = [b1, N[0], N[1]]
    else:
        if COM_NN_D(n1, ABS_Z_N(b1, n1, A1)[1], n2, ABS_Z_N(b2, n2, A2)[1]) == 0:
            Z = [0, 1, [0]]
        elif COM_NN_D(n1, A1, n2, A2) == 2:
            N = SUB_NN_N(n1, A1, n2, A2)
            Z = [b1, N[0], N[1]]
        else:
            N = SUB_NN_N(n2, A2, n1, A1)
            Z = [b2, N[0], N[1]]
    return Z


# Задача Z-7(SUB_ZZ_Z): "Вычитание целых чисел"
# Выполнила Катрущенко О.Д. 1310

# Входные данные:
# b1 - знак первого числа (0 - число положительное, 1 - число отрицательное)
# b2 - знак второго числа (0 - число положительное, 1 - число отрицательное)
# n1 - количество цифр в первом числе
# n2 - количество цифр во втором числе
# A1 - массив цифр первого числа
# A2 - массив цифр второго числа

# Выходные данные:
# b - знак полученного числа (0 - число положительное или равно 0, 1 - число отрицательное)
# n - количество цифр полученного числа
# B - массив цифр полученного числа

def SUB_ZZ_Z(b1, n1, A1, b2, n2, A2):
    B = []
    n = 0
    b = 0

    s1 = POZ_Z_D(b1, n1, A1)  # определение знака первого числа (2 - число положительное, 1 - отрицательное)
    s2 = POZ_Z_D(b2, n2, A2)  # определение знака второго числа (2 - число положительное, 1 - отрицательное)

    n1, A1 = ABS_Z_N(b1, n1, A1)  # получение абсолютной величины (модуля) первого числа
    n2, A2 = ABS_Z_N(b2, n2, A2)  # получение абсолютной величины (модуля) второго числа

    k = COM_NN_D(n1, A1, n2,
                 A2)  # определение, какое число больше по модулю (2 - если первое, 0 - если числа равны, 1 - если второе)

    if (s2 == 0):  # если второе число 0, ответ - первое число
        b, n, B = b1, n1, A1
    elif (s1 == 0):  # если первое число 0, ответ - второе число, умноженное на -1
        b, n, B = MUL_ZM_Z(b2, n2, A2)

    if (((s1 == 2) and (s2 == 2)) or ((s1 == 1) and (s2 == 1))) and (
            k == 0):  # числа равны и имеют одинаковые знаки, разность равна 0
        B = [0]
        n = 1
        b = 0

    # Проверка следующих условий, при которых разность равна сумме модулей и положительна:
    # 1) первое число положительное, второе отрицательное, модули чисел равны
    # 2) первое число положительное, второе отрицательное, модуль первого больше модуля второго
    # 3) первое число положительное, второе отрицательное, модуль первого числа меньше модуля второго
    if ((s1 == 2) and (s2 == 1) and (k == 0)) or ((s1 == 2) and (s2 == 1) and (k == 2)) or (
            (s1 == 2) and (s2 == 1) and (k == 1)):
        n, B = ADD_NN_N(n1, A1, n2, A2)
        b = 0

    # Проверка следующих условий, при которых разность равна сумме модулей и отрицательна:
    # 1) первое число отрицательное, второе положительное, модули чисел равны
    # 2) первое число отрицательное, второе положительное, модуль первого больше модуля второго
    # 3) первое число отрицательное, второе положительное, модуль первого числа меньше модуля второго
    if ((s1 == 1) and (s2 == 2) and (k == 0)) or ((s1 == 1) and (s2 == 2) and (k == 2)) or (
            (s1 == 1) and (s2 == 2) and (k == 1)):
        n, B = ADD_NN_N(n1, A1, n2, A2)
        b = 1

    if (s1 == 2) and (s2 == 2) and (
            k == 2):  # числа положительные, модуль первого больше модуля второго, разность равна разности модулей и положительна
        n, B = SUB_NN_N(n1, A1, n2, A2)
        b = 0

    if (s1 == 1) and (s2 == 1) and (
            k == 2):  # числа отрицательные, модуль первого больше модуля второго, разность равна разности модулей и отрицательна
        n, B = SUB_NN_N(n1, A1, n2, A2)
        b = 1

    if (s1 == 2) and (s2 == 2) and (
            k == 1):  # числа положительные, модуль первого числа меньше модуля второго, разность равна разности модулей и отрицательна
        n, B = SUB_NN_N(n2, A2, n1, A1)
        b = 1

    if (s1 == 1) and (s2 == 1) and (
            k == 1):  # числа отрицательне, модуль первого числа меньше модуля второго, разность равна разности модулей и положительна
        n, B = SUB_NN_N(n2, A2, n1, A1)
        b = 0

    return (b, n, B)


# Задача Z-8(MUL_ZZ_Z): "Умножение целых чисел"
# Выполнил Серкин Д.А. 1310

# Входные данные:
# два целых числа, представленных следующим образом:
# Целое число (b, n; A[..]) - знак числа (1 — минус, 0 — плюс) номер старшей позиции и массив цифр

# Алгоритм:
# Дважды вызывается функция POZ_Z_D() для определения знака каждого из двух чисел.
# Если хотя бы одно число 0, то результат умножения есть 0.
# На основании этого делаем проверку на наличие 0.
# Вызываем функцию ABS_Z_N() дважды для получения абсолютной велечины каждого числа.
# Далее вызываем функцию MUL_NN_N(), которая перемножает два натуральных числа.
# Определяем знак числа, так как натуральные числа всегда положительные, а функция перемножает целые.

# Выходные данные:
# Целое число (b, n, A[..]) - знак числа (1 — минус, 0 — плюс) номер старшей позиции и массив цифр

def MUL_ZZ_Z(b1, n1, A1, b2, n2, A2):
    b_1 = POZ_Z_D(b1, n1, A1)
    b_2 = POZ_Z_D(b2, n2, A2)

    if (b_1 == 0 or b_2 == 0):
        b = 0
        n = 1
        A = [0]
    else:
        n_1, A_1 = ABS_Z_N(b1, n1, A1)
        n_2, A_2 = ABS_Z_N(b2, n2, A2)

        n, A = MUL_NN_N(n1, A1, n2, A2)

        b = (b_1 + b_2) % 2

    return [b, n, A]


# Задача Z-9(DIV_ZZ_Z): "Частное от деления целого на целое"
# Выполнил Шлом И.М. 1310

# Входные данные:
# Программа принимает на вход два целых числа, представленных следующим образом:
# Целое число (b; n; A[..]) - знак перед числом (1 - минус, 0 - плюс), номер старшей позиции и массив цифр

# Алгоритм:
# 1. Создаются натуральные версии обоих полученных чисел
# 2. Проверяется знак у чисел, полученных на вход
# 3. Находится частное от целочисленного деления натуральных версий чисел
# 4. Если оба числа положительны либо делимое положительно, а делитель отрицателен, результат переводится в целое
#    число, знак устанавливается такой же, как у делителя
# 5. Если оба числа отрицательны либо делимое отрицательно, а делитель положителен, в случае несовпадения делимого
#    с произведением результата на делитель к результату прибавляется 1 (в противном случае ничего не прибавляется),
#    после чего он переводится в целое число; если оба числа были отрицательны, устанавливается знак "+", иначе - "-"
# 6. Если делимое число - 0, возвращается 0
# 6. Возвращается полученное частное

# Выходные данные:
# Целое число (b; n; A[..]) - знак, номер старшей позиции и массив цифр - результат целочисленного деления.

def DIV_ZZ_Z(b_1, n_1, A_1, b_2, n_2, A_2):
    res = [0, 1, [0]]
    nat_1 = ABS_Z_N(b_1, n_1, A_1)
    nat_2 = ABS_Z_N(b_2, n_2, A_2)
    if POZ_Z_D(b_1, n_1, A_1) == POZ_Z_D(b_2, n_2, A_2) == 2 or (
            POZ_Z_D(b_1, n_1, A_1) == 2 and POZ_Z_D(b_2, n_2, A_2) == 1):
        res = DIV_NN_N(nat_1[0], nat_1[1], nat_2[0], nat_2[1])
        res = TRANS_N_Z(res[0], res[1])
        res[0] = b_2
    elif (POZ_Z_D(b_1, n_1, A_1) == 1 and POZ_Z_D(b_2, n_2, A_2) == 2) or POZ_Z_D(b_1, n_1, A_1) == POZ_Z_D(b_2, n_2,
                                                                                                            A_2) == 1:
        res = DIV_NN_N(nat_1[0], nat_1[1], nat_2[0], nat_2[1])
        if MUL_NN_N(res[0], res[1], nat_2[0], nat_2[1]) != nat_1:
            res = ADD_1N_N(res[0], res[1])
        res = TRANS_N_Z(res[0], res[1])
        res[0] = 1 if (POZ_Z_D(b_1, n_1, A_1) == 1 and POZ_Z_D(b_2, n_2, A_2) == 2) else 0
    if (res[1] == 1 and res[2][0] == 0):
        res[0] = 0
    return res


# Задача Z-10(MOD_ZZ_Z): "Остаток от деления целого на целое"
# Выполнил Волосевич А.Н. 1310

# Входные данные:
# Программа принимает на вход два целых числа, представленных следующим образом:
# Целое число (b; n; A[..]) - знак перед числом (1 - минус, 0 - плюс), номер старшей позиции и массив цифр

# Алгоритм:
# Получаем частное от деления целого на целое.
# Домножаем делитель на частное
# Вычитаем из первого числа (делимого) результат умножения

# Выходные данные:
# Целое число (b; n; A[..]) - знак, номер старшей позиции и массив цифр - результат целочисленного деления.

def MOD_ZZ_Z(b1: int, n1: int, A1: list, b2: int, n2: int, A2: list) -> tuple:
    ch_b, ch_n, ch_A = DIV_ZZ_Z(b1, n1, A1, b2, n2, A2)
    dl_b, dl_n, dl_A = MUL_ZZ_Z(b2, n2, A2, ch_b, ch_n, ch_A)
    res_b, res_n, res_A = SUB_ZZ_Z(b1, n1, A1, dl_b, dl_n, dl_A)
    return res_b, res_n, res_A